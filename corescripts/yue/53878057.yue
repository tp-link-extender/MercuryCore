import "macros" as { $ }
$load $FILE

return if game.CoreGui.Version < 3
-- peace out if we aren't using the right client

-- A couple of necessary functions
waitForChild = (instance, name) ->
	until instance\FindFirstChild name
		instance.ChildAdded\wait!
	instance\FindFirstChild name

waitForProperty = (instance, property) ->
	until instance[property]
		instance.Changed\wait!

currentLoadout = script.Parent
StaticTabName = "gear"
backpackEnabled = true

robloxGui = game\GetService"CoreGui"\FindFirstChild "RobloxGui"
assert robloxGui
controlFrame = waitForChild robloxGui, "ControlFrame"
backpackButton = waitForChild controlFrame, "BackpackButton"
backpack = waitForChild robloxGui, "Backpack"
waitForChild robloxGui, "CurrentLoadout"
waitForChild robloxGui.CurrentLoadout, "TempSlot"
waitForChild robloxGui.CurrentLoadout.TempSlot, "SlotNumber"

waitForChild currentLoadout, "Background"
clBackground = currentLoadout.Background

IsTouchDevice = ->
	touchEnabled = false
	try
		touchEnabled = Game\GetService"UserInputService".TouchEnabled
	touchEnabled


moveHealthBar = (pGui) ->
	waitForChild pGui, "HealthGUI"
	waitForChild pGui["HealthGUI"], "tray"
	tray = pGui["HealthGUI"]["tray"]
	tray.Position = UDim2.new 0.5, -85, 1, -26


setHealthBarVisible = (pGui, visible) ->
	waitForChild pGui, "HealthGUI"
	waitForChild pGui["HealthGUI"], "tray"
	tray = pGui["HealthGUI"]["tray"]
	tray.Visible = visible


--- Begin Locals
waitForChild game, "Players"
waitForProperty game.Players, "LocalPlayer"
player = game.Players.LocalPlayer

waitForChild player, "PlayerGui"
Spawn ->
	moveHealthBar player.PlayerGui


until player.Character?
	wait 0.03

humanoid = waitForChild player.Character, "Humanoid"
humanoid.Died\connect ->
	backpackButton.Visible = false


waitForChild game, "LocalBackpack"
game.LocalBackpack\SetOldSchoolBackpack false

waitForChild currentLoadout.Parent, "Backpack"
guiBackpack = currentLoadout.Parent.Backpack

backpackManager = waitForChild guiBackpack, "CoreScripts/BackpackScripts/BackpackManager"
backpackOpenEvent = waitForChild backpackManager, "BackpackOpenEvent"
backpackCloseEvent = waitForChild backpackManager, "BackpackCloseEvent"
tabClickedEvent = waitForChild backpackManager, "TabClickedEvent"
-- resizeEvent = waitForChild backpackManager, "ResizeEvent")

inGearTab = true

maxNumLoadoutItems = 10
if robloxGui.AbsoluteSize.Y <= 320
	maxNumLoadoutItems = 4

local characterChildAddedCon, backpackChildCon

debounce = false

enlargeFactor = 1.18
buttonSizeEnlarge = UDim2.new 1 * enlargeFactor, 0, 1 * enlargeFactor, 0
buttonSizeNormal = UDim2.new 1, 0, 1, 0
enlargeOverride = true
guiTweenSpeed = 0.5

firstInstanceOfLoadout = false

inventory = {}

gearSlots = {}
for i = 1, maxNumLoadoutItems
	gearSlots[i] = "empty"


backpackWasOpened = false
--- End Locals

-- Begin Functions
backpackIsOpen = ->
	if guiBackpack
		return guiBackpack.Visible
	false

local reorganizeLoadout
kill = (prop, con, gear) ->
	con?\disconnect!

	if prop == true and gear
		reorganizeLoadout gear, false


registerNumberKeys = ->
	for i = 0, 9
		game\GetService"GuiService"\AddKey "#{i}"

unregisterNumberKeys = ->
	try
		for i = 0, 9
			game\GetService"GuiService"\RemoveKey "#{i}"


characterInWorkspace = ->
	if game.Players["LocalPlayer"] and
		game.Players.LocalPlayer["Character"] and
		game.Players.LocalPlayer.Character? and
		game.Players.LocalPlayer.Character.Parent?

		return true
	false


removeGear = (gear) ->
	local emptySlot
	for i = 1, #gearSlots
		if gearSlots[i] == gear and gear.Parent?
			emptySlot = i
			break


	if emptySlot
		with gearSlots[emptySlot]
			if .GearReference.Value
				if .GearReference.Value.Parent == game.Players.LocalPlayer.Character -- if we currently have this equipped, unequip it
					.GearReference.Value.Parent = game.Players.LocalPlayer.Backpack


				if .GearReference.Value\IsA"HopperBin" and
					.GearReference.Value.Active
					-- this is an active hopperbin
					.GearReference.Value\Disable!
					.GearReference.Value.Active = false

		gearSlots[emptySlot] = "empty"

		-- centerizeX = gear.Size.X.Scale / 2
		-- centerizeY = gear.Size.Y.Scale / 2
		--[[gear\TweenSizeAndPosition(UDim2.new 0,0,0,0,
			UDim2.new(gear.Position.X.Scale + centerizeX,gear.Position.X.Offset,gear.Position.Y.Scale + centerizeY,gear.Position.Y.Offset),
			Enum.EasingDirection.Out, Enum.EasingStyle.Quad,guiTweenSpeed/4,true)]]
		delay 0, ->
			gear\remove!


		Spawn ->
			while backpackIsOpen!
				wait 0.03

			waitForChild player, "Backpack"
			allEmpty = true
			for i = 1, #gearSlots
				if gearSlots[i] ~= "empty"
					allEmpty = false

			if allEmpty
				if #player.Backpack\GetChildren! < 1
					backpackButton.Visible = false
				else
					backpackButton.Position = UDim2.new 0.5, -60, 1, -44

				clBackground.Visible = false


insertGear = (gear, addToSlot) ->
	local pos
	if not addToSlot
		for i = 1, #gearSlots
			if gearSlots[i] == "empty"
				pos = i
				break

		if pos == 1 and gearSlots[1] ~= "empty"
			gear\remove!
			return
		-- we are currently full, can't add in
	else
		pos = addToSlot
		-- push all gear down one slot
		start = 1
		for i = 1, #gearSlots
			if gearSlots[i] == "empty"
				start = i
				break


		for i = start, pos + 1, -1
			gearSlots[i] = gearSlots[i - 1]
			gearSlots[i].SlotNumber.Text = gearSlots[i].SlotNumberDownShadow.Text = gearSlots[i].SlotNumberUpShadow.Text = if i == 10
				"0"
			else
				i


	gearSlots[pos] = gear
	if pos ~= maxNumLoadoutItems
		if type"#{pos}" == "string"
			posString = "#{pos}"
			gear.SlotNumber.Text = posString
			gear.SlotNumberDownShadow.Text = posString
			gear.SlotNumberUpShadow.Text = posString

	else -- tenth gear doesn't follow mathematical pattern :(
		gear.SlotNumber.Text = "0"
		gear.SlotNumberDownShadow.Text = "0"
		gear.SlotNumberUpShadow.Text = "0"

	gear.Visible = true

	con = gear.Kill.Changed\connect (prop) ->
		kill prop, con, gear


reorganizeLoadout = (gear, inserting, _, addToSlot) ->
	if inserting -- add in gear
		insertGear gear, addToSlot
	else
		removeGear gear

	if gear ~= "empty"
		gear.ZIndex = 1


checkToolAncestry = (child, parent) ->
	return if child\FindFirstChild "RobloxBuildTool"
	-- don't show roblox build tools
	if child\IsA"Tool" or child\IsA "HopperBin"
		for i = 1, #gearSlots
			if gearSlots[i] ~= "empty" and gearSlots[i].GearReference.Value == child
				if not parent?
					gearSlots[i].Kill.Value = true
					return false
				elseif child.Parent == player.Character
					gearSlots[i].Selected = true
					return true
				elseif child.Parent == player.Backpack
					if child\IsA"Tool" or child\IsA "HopperBin"
						gearSlots[i].Selected = false

					return true


				gearSlots[i].Kill.Value = true
				return false


removeAllEquippedGear = (physGear) ->
	stuff = player.Character\GetChildren!
	for i = 1, #stuff
		if (stuff[i]\IsA"Tool" or stuff[i]\IsA"HopperBin") and stuff[i] ~= physGear
			if stuff[i]\IsA "Tool"
				stuff[i].Parent = player.Backpack

			if stuff[i]\IsA "HopperBin"
				stuff[i]\Disable!

normalizeButton = (button, speed) ->
	return if not button
	return if button.Size.Y.Scale <= 1
	return if button.Selected
	return if not button.Parent

	moveSpeed = speed
	if not moveSpeed? or type(moveSpeed) ~= "number"
		moveSpeed = guiTweenSpeed / 5

	if button\FindFirstChild "Highlight"
		button.Highlight.Visible = false

	if button\IsA"ImageButton" or button\IsA "TextButton"
		button.ZIndex = 1
		centerizeX = -(buttonSizeNormal.X.Scale - button.Size.X.Scale) / 2
		centerizeY = -(buttonSizeNormal.Y.Scale - button.Size.Y.Scale) / 2
		button\TweenSizeAndPosition(
			buttonSizeNormal,
			UDim2.new(
				button.Position.X.Scale + centerizeX,
				button.Position.X.Offset,
				button.Position.Y.Scale + centerizeY,
				button.Position.Y.Offset
			),
			Enum.EasingDirection.Out,
			Enum.EasingStyle.Quad,
			moveSpeed,
			enlargeOverride
		)

enlargeButton = (button) ->
	return if button.Size.Y.Scale > 1
	return if not button.Parent
	return if not button.Selected

	for i = 1, #gearSlots
		break if gearSlots[i] == "empty"

		if gearSlots[i] ~= button
			normalizeButton gearSlots[i]

	return if not enlargeOverride


	if button\FindFirstChild "Highlight"
		button.Highlight.Visible = true


	if button\IsA"ImageButton" or button\IsA "TextButton"
		button.ZIndex = 5
		centerizeX = -(buttonSizeEnlarge.X.Scale - button.Size.X.Scale) / 2
		centerizeY = -(buttonSizeEnlarge.Y.Scale - button.Size.Y.Scale) / 2
		button\TweenSizeAndPosition(
			buttonSizeEnlarge,
			UDim2.new(
				button.Position.X.Scale + centerizeX,
				button.Position.X.Offset,
				button.Position.Y.Scale + centerizeY,
				button.Position.Y.Offset
			),
			Enum.EasingDirection.Out,
			Enum.EasingStyle.Quad,
			guiTweenSpeed / 5,
			enlargeOverride
		)

hopperBinSwitcher = (numKey, physGear) ->
	return if not physGear

	physGear\ToggleSelect!

	return if gearSlots[numKey] == "empty"

	if not physGear.Active
		gearSlots[numKey].Selected = false
		normalizeButton gearSlots[numKey]
	else
		gearSlots[numKey].Selected = true
		enlargeButton gearSlots[numKey]


toolSwitcher = (numKey) ->
	return if not gearSlots[numKey]

	physGear = gearSlots[numKey].GearReference.Value
	return if not physGear?

	removeAllEquippedGear physGear -- we don't remove this gear, as then we get a double switcheroo

	key = numKey
	if numKey == 0
		key = 10


	for i = 1, #gearSlots
		if gearSlots[i] and gearSlots[i] ~= "empty" and i ~= key
			normalizeButton gearSlots[i]
			with gearSlots[i]
				.Selected = false
				if .GearReference and
					.GearReference.Value and
					.GearReference.Value\IsA"HopperBin" and
					.GearReference.Value.Active

					.GearReference.Value\ToggleSelect!


	if physGear\IsA "HopperBin"
		hopperBinSwitcher numKey, physGear
	else
		if physGear.Parent == player.Character
			physGear.Parent = player.Backpack

			if gearSlots[numKey] ~= "empty"
				gearSlots[numKey].Selected = false
				normalizeButton gearSlots[numKey]

		else
			--player.Character.Humanoid\EquipTool physGear

			physGear.Parent = player.Character
			gearSlots[numKey].Selected = true

			enlargeButton gearSlots[numKey]


activateGear = (num) ->
	local numKey
	numKey = if num == "0"
		10 -- why do lua indexes have to start at 1? :(
	else
		tonumber num

	return if not numKey?

	if gearSlots[numKey] ~= "empty"
		toolSwitcher numKey


normalizeAllButtons = ->
	for i = 1, #gearSlots
		break if gearSlots[i] == "empty"
		if gearSlots[i] ~= button
			normalizeButton gearSlots[i], 0.1


waitForDebounce = ->
	while debounce
		wait!

pointInRectangle = (point, rectTopLeft, rectSize) ->
	if (point.x > rectTopLeft.x and point.x < (rectTopLeft.x + rectSize.x)) or
		(point.y > rectTopLeft.y and point.y < (rectTopLeft.y + rectSize.y))
			return true
	false

swapGear = (gearClone, toFrame) ->
	toFrameChildren = toFrame\GetChildren!
	if #toFrameChildren == 1
		if toFrameChildren[1]\FindFirstChild "SlotNumber"
			toSlot = tonumber toFrameChildren[1].SlotNumber.Text
			gearCloneSlot = tonumber gearClone.SlotNumber.Text
			if toSlot == 0
				toSlot = 10

			if gearCloneSlot == 0
				gearCloneSlot = 10


			gearSlots[toSlot] = gearClone
			gearSlots[gearCloneSlot] = toFrameChildren[1]

			toFrameChildren[1].SlotNumber.Text = gearClone.SlotNumber.Text
			toFrameChildren[1].SlotNumberDownShadow.Text = gearClone.SlotNumber.Text
			toFrameChildren[1].SlotNumberUpShadow.Text = gearClone.SlotNumber.Text

			subString = string.sub toFrame.Name, 5
			gearClone.SlotNumber.Text = subString
			gearClone.SlotNumberDownShadow.Text = subString
			gearClone.SlotNumberUpShadow.Text = subString

			gearClone.Position = UDim2.new gearClone.Position.X.Scale, 0, gearClone.Position.Y.Scale, 0
			toFrameChildren[1].Position = UDim2.new(
				toFrameChildren[1].Position.X.Scale, 0,
				toFrameChildren[1].Position.Y.Scale, 0
			)

			toFrameChildren[1].Parent = gearClone.Parent
			gearClone.Parent = toFrame

	else
		slotNum = tonumber gearClone.SlotNumber.Text
		if slotNum == 0
			slotNum = 10

		gearSlots[slotNum] = "empty" -- reset this gear slot

		subString = string.sub toFrame.Name, 5
		gearClone.SlotNumber.Text = subString
		gearClone.SlotNumberDownShadow.Text = subString
		gearClone.SlotNumberUpShadow.Text = subString

		toSlotNum = tonumber gearClone.SlotNumber.Text
		if toSlotNum == 0
			toSlotNum = 10

		gearSlots[toSlotNum] = gearClone
		gearClone.Position = UDim2.new gearClone.Position.X.Scale, 0, gearClone.Position.Y.Scale, 0
		gearClone.Parent = toFrame


resolveDrag = (gearClone, x, y) ->
	mousePoint = Vector2.new x, y

	frame = gearClone.Parent
	frames = frame.Parent\GetChildren!

	for i = 1, #frames
		if frames[i]\IsA"Frame" and
			pointInRectangle mousePoint, frames[i].AbsolutePosition, frames[i].AbsoluteSize

			swapGear gearClone, frames[i]
			return true

	if (x < frame.AbsolutePosition.x or x > (frame.AbsolutePosition.x + frame.AbsoluteSize.x)) or
		(y < frame.AbsolutePosition.y or y > (frame.AbsolutePosition.y + frame.AbsoluteSize.y))

		reorganizeLoadout gearClone, false
		return false
	else
		if dragBeginPos
			gearClone.Position = dragBeginPos

		return -1


unequipAllItems = (dontEquipThis) ->
	for i = 1, #gearSlots
		break if gearSlots[i] == "empty"

		with gearSlots[i]
			if .GearReference.Value and .GearReference.Value ~= dontEquipThis
				if .GearReference.Value\IsA "HopperBin"
					.GearReference.Value\Disable!
				elseif .GearReference.Value\IsA "Tool"
					.GearReference.Value.Parent = game.Players.LocalPlayer.Backpack

				.Selected = false


showToolTip = (button, tip) ->
	if button and
		button\FindFirstChild"ToolTipLabel" and
		button.ToolTipLabel\IsA"TextLabel" and
		not IsTouchDevice!

		button.ToolTipLabel.Text = "#{tip}"
		xSize = button.ToolTipLabel.TextBounds.X + 6
		button.ToolTipLabel.Size = UDim2.new 0, xSize, 0, 20
		button.ToolTipLabel.Position = UDim2.new 0.5, -xSize / 2, 0, -30
		button.ToolTipLabel.Visible = true


hideToolTip = (button, _) ->
	if button and button\FindFirstChild"ToolTipLabel" and button.ToolTipLabel\IsA "TextLabel"
		button.ToolTipLabel.Visible = false

removeFromInventory = (child) ->
	for i = 1, #inventory
		if inventory[i] == child
			table.remove inventory, i
			inventory[i] = nil

addingPlayerChild = (child, equipped, addToSlot, inventoryGearButton) ->
	waitForDebounce!
	debounce = true

	if child\FindFirstChild"RobloxBuildTool"
		debounce = false
		return
	-- don't show roblox build tools
	if not child\IsA"Tool" and
		not child\IsA "HopperBin"

		debounce = false
		return -- we don't care about anything besides tools (sigh...)


	if not addToSlot
		for i = 1, #gearSlots
			if gearSlots[i] ~= "empty" and gearSlots[i].GearReference.Value == child -- we already have gear, do nothing
				debounce = false
				return


	gearClone = currentLoadout.TempSlot\clone!
	gearClone.Name = child.Name
	gearClone.GearImage.Image = child.TextureId
	if gearClone.GearImage.Image == ""
		gearClone.GearText.Text = child.Name

	gearClone.GearReference.Value = child

	gearClone.MouseEnter\connect ->
		if gearClone.GearReference and
			gearClone.GearReference.Value["ToolTip"] and
			gearClone.GearReference.Value.ToolTip ~= ""

			showToolTip gearClone, gearClone.GearReference.Value.ToolTip


	gearClone.MouseLeave\connect ->
		if gearClone.GearReference and
			gearClone.GearReference.Value["ToolTip"] and
			gearClone.GearReference.Value.ToolTip ~= ""

			hideToolTip gearClone, gearClone.GearReference.Value.ToolTip


	gearClone.RobloxLocked = true

	slotToMod = -1

	if not addToSlot
		for i = 1, #gearSlots
			if gearSlots[i] == "empty"
				slotToMod = i
				break

	else
		slotToMod = addToSlot


	if slotToMod == -1 -- No available slot to add in!
		debounce = false
		return


	slotNum = slotToMod % 10
	parent = currentLoadout\FindFirstChild "Slot#{slotNum}"
	gearClone.Parent = parent

	if inventoryGearButton
		absolutePositionFinal = inventoryGearButton.AbsolutePosition
		currentAbsolutePosition = gearClone.AbsolutePosition
		diff = absolutePositionFinal - currentAbsolutePosition
		gearClone.Position = UDim2.new gearClone.Position.X.Scale, diff.x, gearClone.Position.Y.Scale, diff.y
		gearClone.ZIndex = 4


	reorganizeLoadout gearClone, if addToSlot
		true, equipped, addToSlot
	else
		true


	if not gearClone.Parent?
		debounce = false
		return
	-- couldn't fit in (hopper is full!)

	if equipped
		gearClone.Selected = true
		unequipAllItems child
		delay guiTweenSpeed + 0.01, -> -- if our gear is equipped, we will want to enlarge it when done moving
			if gearClone\FindFirstChild"GearReference" and (
					(gearClone.GearReference.Value\IsA"Tool" and gearClone.GearReference.Value.Parent == player.Character) or
					(gearClone.GearReference.Value\IsA"HopperBin" and gearClone.GearReference.Value.Active == true)
				)

				enlargeButton gearClone


	local dragBeginPos
	local clickCon, buttonDeleteCon, mouseEnterCon, mouseLeaveCon, dragStop, dragBegin
	clickCon = gearClone.MouseButton1Click\connect ->
		if characterInWorkspace!
			if not gearClone.Draggable
				activateGear gearClone.SlotNumber.Text


	mouseEnterCon = gearClone.MouseEnter\connect ->
		if guiBackpack.Visible
			gearClone.Draggable = true


	dragBegin = gearClone.DragBegin\connect (pos) ->
		dragBeginPos = pos
		gearClone.ZIndex = 7
		children = gearClone\GetChildren!
		for i = 1, #children
			if children[i]\IsA "TextLabel"
				children[i].ZIndex = if string.find children[i].Name, "Shadow"
					8
				else
					9

			elseif children[i]\IsA"Frame" or children[i]\IsA "ImageLabel"
				children[i].ZIndex = 7


	dragStop = gearClone.DragStopped\connect (x, y) ->
		gearClone.ZIndex = if gearClone.Selected
			4
		else
			3

		children = gearClone\GetChildren!
		for i = 1, #children
			if children[i]\IsA "TextLabel"
				children[i].ZIndex = if string.find children[i].Name, "Shadow"
					3
				else
					4

			elseif children[i]\IsA"Frame" or children[i]\IsA "ImageLabel"
				children[i].ZIndex = 2

		resolveDrag gearClone, x, y

	mouseLeaveCon = gearClone.MouseLeave\connect ->
		gearClone.Draggable = false

	buttonDeleteCon = gearClone.AncestryChanged\connect ->
		return if gearClone.Parent and gearClone.Parent.Parent == currentLoadout

		clickCon?\disconnect!
		buttonDeleteCon?\disconnect!
		mouseEnterCon?\disconnect!
		mouseLeaveCon?\disconnect!
		dragStop?\disconnect!
		dragBegin?\disconnect!
	-- this probably isn't necessary since objects are being deleted (probably), but this might still leak just in case

	local childCon
	local childChangeCon
	childCon = child.AncestryChanged\connect (newChild, parent) ->
		if not checkToolAncestry newChild, parent

			childCon?\disconnect!
			childChangeCon?\disconnect!

			removeFromInventory child
		elseif parent == game.Players.LocalPlayer.Backpack
			normalizeButton gearClone


	childChangeCon = child.Changed\connect (prop) ->
		if prop == "Name"
			if gearClone and gearClone.GearImage.Image == ""
				gearClone.GearText.Text = child.Name

		elseif prop == "Active"
			if child and child\IsA "HopperBin"
				if not child.Active
					gearClone.Selected = false
					normalizeButton gearClone


		elseif prop == "TextureId"
			gearClone.GearImage.Image = child.TextureId


	debounce = false

	Spawn ->
		while backpackIsOpen!
			wait 0.03

		for i = 1, #gearSlots
			if gearSlots[i] ~= "empty"
				backpackButton.Position = UDim2.new 0.5, -60, 1, -108
				if backpackEnabled
					backpackButton.Visible = true
					clBackground.Visible = true


addToInventory = (child) ->
	return if not child\IsA"Tool" or not child\IsA "HopperBin"

	local slot
	for i = 1, #inventory
		return if inventory[i] and inventory[i] == child

		if not inventory[i]
			slot = i

	if slot
		inventory[slot] = child
	elseif #inventory < 1
		inventory[1] = child
	else
		inventory[] = child


spreadOutGear = ->
	loadoutChildren = currentLoadout\GetChildren!

	for i = 1, #loadoutChildren
		if loadoutChildren[i]\IsA "Frame"
			loadoutChildren[i].BackgroundTransparency = 0.5
			slot = tonumber string.sub loadoutChildren[i].Name, 5
			if slot == 0
				slot = 10

			if robloxGui.AbsoluteSize.Y <= 320
				loadoutChildren[i]\TweenPosition(
					UDim2.new(0, (slot - 1) * 60, 0, 0),
					Enum.EasingDirection.Out,
					Enum.EasingStyle.Quad,
					0.25,
					true
				)
			else
				loadoutChildren[i]\TweenPosition(
					UDim2.new((slot - 1) / 10, 0, 0, 0),
					Enum.EasingDirection.Out,
					Enum.EasingStyle.Quad,
					0.25,
					true
				)


centerGear = ->
	loadoutChildren = currentLoadout\GetChildren!
	gearButtons = {}
	local lastSlotAdd

	for i = 1, #loadoutChildren
		if loadoutChildren[i]\IsA "Frame"
			if #loadoutChildren[i]\GetChildren! > 0
				if loadoutChildren[i].Name == "Slot0"
					lastSlotAdd = loadoutChildren[i]
				else
					table.insert gearButtons, loadoutChildren[i]


			loadoutChildren[i].BackgroundTransparency = 1


	if lastSlotAdd
		table.insert gearButtons, lastSlotAdd


	startPos = (1 - (#gearButtons * 0.1)) / 2
	for i = 1, #gearButtons
		if robloxGui.AbsoluteSize.Y <= 320
			startPos = 0.5 - (#gearButtons * 0.333) / 2
			gearButtons[i]\TweenPosition(
				UDim2.new(startPos + (i - 1) * 0.33, 0, 0, 0),
				Enum.EasingDirection.Out,
				Enum.EasingStyle.Quad,
				0.25,
				true
			)
		else
			gearButtons[i]\TweenPosition(
				UDim2.new(startPos + ((i - 1) * 0.1), 0, 0, 0),
				Enum.EasingDirection.Out,
				Enum.EasingStyle.Quad,
				0.25,
				true
			)


editLoadout = ->
	backpackWasOpened = true
	if inGearTab
		spreadOutGear!


readonlyLoadout = ->
	if not inGearTab
		centerGear!


setupBackpackListener = ->
	backpackChildCon?\disconnect!
	backpackChildCon = nil

	backpackChildCon = player.Backpack.ChildAdded\connect (child) ->
		if not firstInstanceOfLoadout
			firstInstanceOfLoadout = true
			if backpackEnabled
				backpackButton.Visible = true
				clBackground.Visible = true

		addingPlayerChild child
		addToInventory child


playerCharacterChildAdded = (child) ->
	addingPlayerChild child, true
	addToInventory child


activateLoadout = ->
	currentLoadout.Visible = true


deactivateLoadout = ->
	currentLoadout.Visible = false


tabHandler = (inFocus) ->
	inGearTab = inFocus
	if inFocus
		editLoadout!
	else
		readonlyLoadout!


coreGuiChanged = (coreGuiType, enabled) ->
	if coreGuiType == Enum.CoreGuiType.Backpack or coreGuiType == Enum.CoreGuiType.All
		backpackButton.Visible = enabled
		clBackground.Visible = enabled
		backpackEnabled = enabled

		if enabled
			registerNumberKeys!
		else
			unregisterNumberKeys!


	if coreGuiType == Enum.CoreGuiType.Health or coreGuiType == Enum.CoreGuiType.All
		setHealthBarVisible game.Players.LocalPlayer.PlayerGui, enabled


-- End Functions

-- Begin Script
registerNumberKeys!

try
	coreGuiChanged Enum.CoreGuiType.Backpack, Game.StarterGui\GetCoreGuiEnabled Enum.CoreGuiType.Backpack
	coreGuiChanged Enum.CoreGuiType.Health, Game.StarterGui\GetCoreGuiEnabled Enum.CoreGuiType.Health
	Game.StarterGui.CoreGuiChangedSignal\connect coreGuiChanged


wait! -- let stuff initialize incase this is first heartbeat...

waitForChild player, "Backpack"
waitForProperty player, "Character"

-- not sure why this had no delay but the player.CharacterAdded one had one... this type of error would be easier to avoid with function reusage
delay 1, ->
	backpackChildren = player.Backpack\GetChildren!
	size = math.min 10, #backpackChildren
	for i = 1, size
		if backpackEnabled
			backpackButton.Visible = true
			clBackground.Visible = true

		addingPlayerChild backpackChildren[i], false

	setupBackpackListener!


delay 2, ->
	--while true
	if not backpackWasOpened
		if robloxGui.AbsoluteSize.Y <= 320
			cChildren = currentLoadout\GetChildren!
			for i = 1, #cChildren
				slotNum = tonumber string.sub cChildren[i].Name, 5, string.len cChildren[i].Name
				if type(slotNum) == "number"
					cChildren[i].Position = UDim2.new 0, (slotNum - 1) * 60, 0, 0

	wait 0.25


player.ChildAdded\connect (child) ->
	if child\IsA "PlayerGui"
		moveHealthBar child


waitForProperty player, "Character"
for _, v in ipairs player.Character\GetChildren!
	playerCharacterChildAdded v

characterChildAddedCon = player.Character.ChildAdded\connect (child) ->
	playerCharacterChildAdded child


waitForChild player.Character, "Humanoid"
humanoidDiedCon = player.Character.Humanoid.Died\connect ->
	humanoidDiedCon?\disconnect!
	global humanoidDiedCon = nil

	deactivateLoadout!
	backpackChildCon?\disconnect!
	backpackChildCon = nil

	backpackWasOpened = false


player.CharacterRemoving\connect ->
	for i = 1, #gearSlots
		if gearSlots[i] ~= "empty"
			gearSlots[i].Parent = nil
			gearSlots[i] = "empty"


player.CharacterAdded\connect ->
	waitForProperty game.Players, "LocalPlayer"
	player = game.Players.LocalPlayer -- make sure we are still looking at the correct character
	waitForChild player, "Backpack"

	delay 1, ->
		backpackChildren = player.Backpack\GetChildren!
		size = math.min 10, #backpackChildren
		for i = 1, size
			if backpackEnabled
				backpackButton.Visible = true
				clBackground.Visible = true

			addingPlayerChild backpackChildren[i], false
		setupBackpackListener!
	activateLoadout!

	characterChildAddedCon?\disconnect!

	characterChildAddedCon = player.Character.ChildAdded\connect (child) ->
		addingPlayerChild child, true


	waitForChild player.Character, "Humanoid"
	if backpack.Visible
		backpackOpenEvent\Fire!

	humanoidDiedCon = player.Character.Humanoid.Died\connect ->
		if backpackEnabled
			backpackButton.Visible = false
			clBackground.Visible = false

		firstInstanceOfLoadout = false
		deactivateLoadout!

		humanoidDiedCon?\disconnect!
		humanoidDiedCon = nil

		backpackChildCon?\disconnect!
		backpackChildCon = nil


	waitForChild player, "PlayerGui"
	moveHealthBar player.PlayerGui
	delay 2, ->
		--while true
		if (not backpackWasOpened) and
			(robloxGui.AbsoluteSize.Y <= 320)

			cChildren = currentLoadout\GetChildren!
			for i = 1, #cChildren
				slotNum = tonumber string.sub cChildren[i].Name, 5, string.len cChildren[i].Name
				if type(slotNum) == "number"
					cChildren[i].Position = UDim2.new 0, (slotNum - 1) * 60, 0, 0

		wait 0.25

waitForChild guiBackpack, "SwapSlot"
guiBackpack.SwapSlot.Changed\connect ->
	if guiBackpack.SwapSlot.Value
		swapSlot = guiBackpack.SwapSlot
		pos = swapSlot.Slot.Value
		if pos == 0
			pos = 10

		if gearSlots[pos]
			reorganizeLoadout gearSlots[pos], false

		if swapSlot.GearButton.Value
			addingPlayerChild swapSlot.GearButton.Value.GearReference.Value, false, pos

		guiBackpack.SwapSlot.Value = false


game\GetService"GuiService".KeyPressed\connect (key) ->
	if characterInWorkspace!
		activateGear key


backpackOpenEvent.Event\connect editLoadout
backpackCloseEvent.Event\connect centerGear
tabClickedEvent.Event\connect (tabName) ->
	tabHandler tabName == StaticTabName
